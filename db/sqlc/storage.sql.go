// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: storage.sql

package db

import (
	"context"
	"database/sql"
)

const createStorage = `-- name: CreateStorage :one
INSERT INTO storage (
    access_token,
    refresh_token,
    email
) VALUES (
    $1,
    $2,
    $3
)
RETURNING id, access_token, refresh_token, is_refresh_token_expired, created_at, updated_at, email, access_token_expires_in
`

type CreateStorageParams struct {
	AccessToken  string `json:"access_token"`
	RefreshToken string `json:"refresh_token"`
	Email        string `json:"email"`
}

func (q *Queries) CreateStorage(ctx context.Context, arg CreateStorageParams) (Storage, error) {
	row := q.db.QueryRowContext(ctx, createStorage, arg.AccessToken, arg.RefreshToken, arg.Email)
	var i Storage
	err := row.Scan(
		&i.ID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.IsRefreshTokenExpired,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Email,
		&i.AccessTokenExpiresIn,
	)
	return i, err
}

const getStorage = `-- name: GetStorage :one
SELECT id, access_token, refresh_token, is_refresh_token_expired, created_at, updated_at, email, access_token_expires_in FROM storage
WHERE id = $1 OR email = $2
LIMIT 1
`

type GetStorageParams struct {
	ID    int64  `json:"id"`
	Email string `json:"email"`
}

func (q *Queries) GetStorage(ctx context.Context, arg GetStorageParams) (Storage, error) {
	row := q.db.QueryRowContext(ctx, getStorage, arg.ID, arg.Email)
	var i Storage
	err := row.Scan(
		&i.ID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.IsRefreshTokenExpired,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Email,
		&i.AccessTokenExpiresIn,
	)
	return i, err
}

const listStorage = `-- name: ListStorage :many
SELECT id, access_token, refresh_token, is_refresh_token_expired, created_at, updated_at, email, access_token_expires_in FROM storage
`

func (q *Queries) ListStorage(ctx context.Context) ([]Storage, error) {
	rows, err := q.db.QueryContext(ctx, listStorage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Storage{}
	for rows.Next() {
		var i Storage
		if err := rows.Scan(
			&i.ID,
			&i.AccessToken,
			&i.RefreshToken,
			&i.IsRefreshTokenExpired,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Email,
			&i.AccessTokenExpiresIn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStorage = `-- name: UpdateStorage :one
UPDATE storage
SET
    access_token = COALESCE($2, access_token),
    refresh_token = COALESCE($3, refresh_token),
    is_refresh_token_expired = COALESCE($4, is_refresh_token_expired),
    access_token_expires_in = COALESCE($5, access_token_expires_in),
    updated_at = NOW()
WHERE id = $1
RETURNING id, access_token, refresh_token, is_refresh_token_expired, created_at, updated_at, email, access_token_expires_in
`

type UpdateStorageParams struct {
	ID                    int64          `json:"id"`
	AccessToken           sql.NullString `json:"access_token"`
	RefreshToken          sql.NullString `json:"refresh_token"`
	IsRefreshTokenExpired sql.NullBool   `json:"is_refresh_token_expired"`
	AccessTokenExpiresIn  sql.NullInt32  `json:"access_token_expires_in"`
}

func (q *Queries) UpdateStorage(ctx context.Context, arg UpdateStorageParams) (Storage, error) {
	row := q.db.QueryRowContext(ctx, updateStorage,
		arg.ID,
		arg.AccessToken,
		arg.RefreshToken,
		arg.IsRefreshTokenExpired,
		arg.AccessTokenExpiresIn,
	)
	var i Storage
	err := row.Scan(
		&i.ID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.IsRefreshTokenExpired,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Email,
		&i.AccessTokenExpiresIn,
	)
	return i, err
}
